<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Effective STL 总结 | byhj zzZ~~~</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="容器　  　对于C++而言，容器是比数组功能更强大更灵活的工具，它可以动态增长或缩减，可以自己管理内存，可以自己记住包含了多少对象，它们还限定了自己所支持的操作的复杂性。对于不同情况我们需要选择不同的容器。">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective STL 总结">
<meta property="og:url" content="http://byhj.github.io/2015/12/24/EffectiveSTL/index.html">
<meta property="og:site_name" content="byhj zzZ~~~">
<meta property="og:description" content="容器　  　对于C++而言，容器是比数组功能更强大更灵活的工具，它可以动态增长或缩减，可以自己管理内存，可以自己记住包含了多少对象，它们还限定了自己所支持的操作的复杂性。对于不同情况我们需要选择不同的容器。">
<meta property="og:updated_time" content="2015-12-25T11:21:12.068Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Effective STL 总结">
<meta name="twitter:description" content="容器　  　对于C++而言，容器是比数组功能更强大更灵活的工具，它可以动态增长或缩减，可以自己管理内存，可以自己记住包含了多少对象，它们还限定了自己所支持的操作的复杂性。对于不同情况我们需要选择不同的容器。">
  
    <link rel="alternative" href="/atom.xml" title="byhj zzZ~~~" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
    <link rel="icon" href="/byhj.ico">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/assets/img/byhj.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">byhj</a></h1>
		</hgroup>

		
		<p class="header-subtitle">世上的鲜花会盛开，壮丽不朽的事物会接踵而来</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/byhj" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/byhj" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/Book/" style="font-size: 10px;">Book</a> <a href="/tags/C/" style="font-size: 17.5px;">C++</a> <a href="/tags/Cocos2dx/" style="font-size: 10px;">Cocos2dx</a> <a href="/tags/D3D/" style="font-size: 12.5px;">D3D</a> <a href="/tags/D3D12/" style="font-size: 12.5px;">D3D12</a> <a href="/tags/Direct3D/" style="font-size: 10px;">Direct3D</a> <a href="/tags/DirectX/" style="font-size: 15px;">DirectX</a> <a href="/tags/GUI/" style="font-size: 10px;">GUI</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Math/" style="font-size: 12.5px;">Math</a> <a href="/tags/OGRE/" style="font-size: 10px;">OGRE</a> <a href="/tags/OpenGL/" style="font-size: 20px;">OpenGL</a> <a href="/tags/OpenGL-GLSL/" style="font-size: 10px;">OpenGL GLSL</a> <a href="/tags/Pattern/" style="font-size: 10px;">Pattern</a> <a href="/tags/Qt静态编译-MSVC/" style="font-size: 10px;">Qt静态编译-MSVC</a> <a href="/tags/Vulkan/" style="font-size: 10px;">Vulkan</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">爱书爱自然的一只鱼~~</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">byhj</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/assets/img/byhj.png" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">byhj</h1>
			</hgroup>
			
			<p class="header-subtitle">世上的鲜花会盛开，壮丽不朽的事物会接踵而来</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/byhj" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/byhj" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-EffectiveSTL" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/24/EffectiveSTL/" class="article-date">
  	<time datetime="2015-12-24T07:00:23.000Z" itemprop="datePublished">2015-12-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Effective STL 总结
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    
    <div class="article-entry" itemprop="articleBody">
  
    
    <div id="toc" class="article-toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#容器"><span class="toc-number">1.</span> <span class="toc-text">容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#慎重选择容器类型"><span class="toc-number">1.1.</span> <span class="toc-text">慎重选择容器类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不要试图编写独立于容器类型的代码"><span class="toc-number">1.2.</span> <span class="toc-text">不要试图编写独立于容器类型的代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#确保容器中的对象副本正确而高效"><span class="toc-number">1.3.</span> <span class="toc-text">确保容器中的对象副本正确而高效</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调用empty而不是检测size()是否为0"><span class="toc-number">1.4.</span> <span class="toc-text">调用empty而不是检测size()是否为0</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#区间成员函数优先于与之对应的单元素成员函数"><span class="toc-number">1.5.</span> <span class="toc-text">区间成员函数优先于与之对应的单元素成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#当心C++编译器最烦人的分析机制"><span class="toc-number">1.6.</span> <span class="toc-text">当心C++编译器最烦人的分析机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如果容器中包含通过new操作创建的指针，切记在容器对象析构前将指针delete掉"><span class="toc-number">1.7.</span> <span class="toc-text">如果容器中包含通过new操作创建的指针，切记在容器对象析构前将指针delete掉</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#切勿创建包含auto_ptr的容器对象"><span class="toc-number">1.8.</span> <span class="toc-text">切勿创建包含auto_ptr的容器对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#了解分配子的约定和限制"><span class="toc-number">1.9.</span> <span class="toc-text">了解分配子的约定和限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#理解自定义分配子的合理用法"><span class="toc-number">1.10.</span> <span class="toc-text">理解自定义分配子的合理用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#切勿对STL容器的线程安全性有不切实际的依赖"><span class="toc-number">1.11.</span> <span class="toc-text">切勿对STL容器的线程安全性有不切实际的依赖</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vector和string"><span class="toc-number">2.</span> <span class="toc-text">vector和string</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vector和string优先于动态分配的数组"><span class="toc-number">2.1.</span> <span class="toc-text">vector和string优先于动态分配的数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用reserve来避免不必要的重新分配"><span class="toc-number">2.2.</span> <span class="toc-text">使用reserve来避免不必要的重新分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注意string实现的多样性"><span class="toc-number">2.3.</span> <span class="toc-text">注意string实现的多样性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#了解如何把vector和string数据传给旧的API"><span class="toc-number">2.4.</span> <span class="toc-text">了解如何把vector和string数据传给旧的API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用“swap技巧”除去多余的容量"><span class="toc-number">2.5.</span> <span class="toc-text">使用“swap技巧”除去多余的容量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#避免试图vector"><span class="toc-number">2.6.</span> <span class="toc-text">避免试图vector</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#关联容器"><span class="toc-number">3.</span> <span class="toc-text">关联容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#理解相等和等价的区别"><span class="toc-number">3.1.</span> <span class="toc-text">理解相等和等价的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为包含指针的关联容器指定比较类型"><span class="toc-number">3.2.</span> <span class="toc-text">为包含指针的关联容器指定比较类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总是让比较函数在等值情况下返回false"><span class="toc-number">3.3.</span> <span class="toc-text">总是让比较函数在等值情况下返回false</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#切勿直接修改set或multiset中的键"><span class="toc-number">3.4.</span> <span class="toc-text">切勿直接修改set或multiset中的键</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#考虑用排序的vector替代关联容器"><span class="toc-number">3.5.</span> <span class="toc-text">考虑用排序的vector替代关联容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#当笑料至关重要时，请在map::operator[]与map::insert之间谨慎做出选择"><span class="toc-number">3.6.</span> <span class="toc-text">当笑料至关重要时，请在map::operator[]与map::insert之间谨慎做出选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#熟悉非标准的散列容器"><span class="toc-number">3.7.</span> <span class="toc-text">熟悉非标准的散列容器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#迭代器"><span class="toc-number">4.</span> <span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#iterator优先于const_iterator,_reverse_iterator,_const_reverse_iterator"><span class="toc-number">4.1.</span> <span class="toc-text">iterator优先于const_iterator, reverse_iterator, const_reverse_iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用distance和advnace将容器的const_iteator转换成iterator"><span class="toc-number">4.2.</span> <span class="toc-text">使用distance和advnace将容器的const_iteator转换成iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#正确理解由reverse_iterator的base()成员函数所产生的iterator的用法"><span class="toc-number">4.3.</span> <span class="toc-text">正确理解由reverse_iterator的base()成员函数所产生的iterator的用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对于逐个字符的输入请考虑使用istreambuf_iterator"><span class="toc-number">4.4.</span> <span class="toc-text">对于逐个字符的输入请考虑使用istreambuf_iterator</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#算法"><span class="toc-number">5.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#确保目标区间足够大"><span class="toc-number">5.1.</span> <span class="toc-text">确保目标区间足够大</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#了解各种和排序有关的选择"><span class="toc-number">5.2.</span> <span class="toc-text">了解各种和排序有关的选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如果确实需要删除元素，则需要在remove这一类算法之后调用erase"><span class="toc-number">5.3.</span> <span class="toc-text">如果确实需要删除元素，则需要在remove这一类算法之后调用erase</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对包含指针的容器使用remove这一类算法时要特别小心"><span class="toc-number">5.4.</span> <span class="toc-text">对包含指针的容器使用remove这一类算法时要特别小心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#了解哪些算法要求使用排序的区间作为参数"><span class="toc-number">5.5.</span> <span class="toc-text">了解哪些算法要求使用排序的区间作为参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通过mismatch或lexicographical_compare实现简单的忽略大小写的字符串比较"><span class="toc-number">5.6.</span> <span class="toc-text">通过mismatch或lexicographical_compare实现简单的忽略大小写的字符串比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#理解copy_if算法的正确实现"><span class="toc-number">5.7.</span> <span class="toc-text">理解copy_if算法的正确实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用accumulate或者for_each进行区间统计"><span class="toc-number">5.8.</span> <span class="toc-text">使用accumulate或者for_each进行区间统计</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数子，函数子类，函数及其他"><span class="toc-number">6.</span> <span class="toc-text">函数子，函数子类，函数及其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#遵循按值传递的原则来设计函数子类"><span class="toc-number">6.1.</span> <span class="toc-text">遵循按值传递的原则来设计函数子类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#确保判别式是”纯函数”"><span class="toc-number">6.2.</span> <span class="toc-text">确保判别式是”纯函数”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#若一个类是函数子，则应使它可配接"><span class="toc-number">6.3.</span> <span class="toc-text">若一个类是函数子，则应使它可配接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#理解ptr_fun,_mem_fun和mem_fun_ref的来由"><span class="toc-number">6.4.</span> <span class="toc-text">理解ptr_fun, mem_fun和mem_fun_ref的来由</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#确保less与operator<具有相同的语义"><span class="toc-number">6.5.</span> <span class="toc-text">确保less与operator<具有相同的语义</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#在程序中使用STL"><span class="toc-number">7.</span> <span class="toc-text">在程序中使用STL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#算法调用优先于手写的循环"><span class="toc-number">7.1.</span> <span class="toc-text">算法调用优先于手写的循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#容器的成员函数优先于同名的算法"><span class="toc-number">7.2.</span> <span class="toc-text">容器的成员函数优先于同名的算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#正确区分const,_find,_binary_search,_lower_bound,_upper_bound和equal_range"><span class="toc-number">7.3.</span> <span class="toc-text">正确区分const, find, binary_search, lower_bound, upper_bound和equal_range</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#考虑使用函数对象而不是函数作为STL算法的参数"><span class="toc-number">7.4.</span> <span class="toc-text">考虑使用函数对象而不是函数作为STL算法的参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#考虑产生”直写型”的代码"><span class="toc-number">7.5.</span> <span class="toc-text">考虑产生”直写型”的代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总是包含正确的头文件"><span class="toc-number">7.6.</span> <span class="toc-text">总是包含正确的头文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#学会分享与STL相关的编译器诊断信息"><span class="toc-number">7.7.</span> <span class="toc-text">学会分享与STL相关的编译器诊断信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#熟悉与STL相关的Web站点"><span class="toc-number">7.8.</span> <span class="toc-text">熟悉与STL相关的Web站点</span></a></li></ol></li></ol>
      <hr/>
    </div>
    
    <h1 id="容器">容器</h1><p>　  　对于C++而言，容器是比数组功能更强大更灵活的工具，它可以动态增长或缩减，可以自己管理内存，可以自己记住包含了多少对象，它们还限定了自己所支持的操作的复杂性。对于不同情况我们需要选择不同<br>的容器。</p>
<p><a id="more"></a>　</p>
<h2 id="慎重选择容器类型">慎重选择容器类型</h2><p>　　C++主要提供了一下几种类型的容器</p>
<ul>
<li>标准STL序列容器：vector, string, deque, list</li>
<li>标准STL管理容器：set,  multiset, map, multimap</li>
<li>非标准序列容器 ：slist, rope</li>
<li>非标准关联容器 ：hash_set, hash_multiset, hash_map, hash_multimap</li>
<li>几种标准的非STL容器：bitset, valarray, stack, queue, priority_queue</li>
</ul>
<p>　　在不同情况下我们需要采用不同的容器，一般情况下我们都使用vector容器。我们主要把容器以两种方法进行<br>分类：</p>
<ul>
<li>对连续内存容器：把它的元素存放在一块或多块(动态分配)内存中，每块内存中存有多个元素。</li>
<li>基于节点的容器：容器中元素的插入或删除只影响到指向节点的指针，而不影响节点本身的内容。</li>
</ul>
<p>下面分别介绍在不同情况下怎么选择合适的容器：</p>
<p>1.在容器的任意位置插入新元素：选择序列容器。<br>2.是否关系容器中元素是排序的：不关心使用散列容器，关心则避免。<br>3.必须是标准C++一部分：不是可以考虑slist, rope。<br>4.需要哪种类型迭代器:<br>5.当发生元素的插入或删除时，避免移动原来容器元素是否很重要<br>6.容器中元素的布局是否需要和C兼容：<br>7：元素的查找速度是否是关键的考虑因素：<br>8：容器内部使用了引用计数技术：<br>9：对插入和删除操作，需要事物语义:<br>10:需要时迭代器，指针和引用变为无效的次数最少：<br>11：序列容器迭代器是随机访问类型，只有没有删除操作发生，且插入操作发生在容器末尾，则指向数据的指针和引用就不会变为无效：deque</p>
<h2 id="不要试图编写独立于容器类型的代码">不要试图编写独立于容器类型的代码</h2><h2 id="确保容器中的对象副本正确而高效">确保容器中的对象副本正确而高效</h2><h2 id="调用empty而不是检测size()是否为0">调用empty而不是检测size()是否为0</h2><h2 id="区间成员函数优先于与之对应的单元素成员函数">区间成员函数优先于与之对应的单元素成员函数</h2><h2 id="当心C++编译器最烦人的分析机制">当心C++编译器最烦人的分析机制</h2><h2 id="如果容器中包含通过new操作创建的指针，切记在容器对象析构前将指针delete掉">如果容器中包含通过new操作创建的指针，切记在容器对象析构前将指针delete掉</h2><h2 id="切勿创建包含auto_ptr的容器对象">切勿创建包含auto_ptr的容器对象</h2><h2 id="了解分配子的约定和限制">了解分配子的约定和限制</h2><h2 id="理解自定义分配子的合理用法">理解自定义分配子的合理用法</h2><h2 id="切勿对STL容器的线程安全性有不切实际的依赖">切勿对STL容器的线程安全性有不切实际的依赖</h2><hr>
<h1 id="vector和string">vector和string</h1><h2 id="vector和string优先于动态分配的数组">vector和string优先于动态分配的数组</h2><h2 id="使用reserve来避免不必要的重新分配">使用reserve来避免不必要的重新分配</h2><h2 id="注意string实现的多样性">注意string实现的多样性</h2><h2 id="了解如何把vector和string数据传给旧的API">了解如何把vector和string数据传给旧的API</h2><h2 id="使用“swap技巧”除去多余的容量">使用“swap技巧”除去多余的容量</h2><h2 id="避免试图vector">避免试图vector<bool></bool></h2><hr>
<h1 id="关联容器">关联容器</h1><h2 id="理解相等和等价的区别">理解相等和等价的区别</h2><h2 id="为包含指针的关联容器指定比较类型">为包含指针的关联容器指定比较类型</h2><h2 id="总是让比较函数在等值情况下返回false">总是让比较函数在等值情况下返回false</h2><h2 id="切勿直接修改set或multiset中的键">切勿直接修改set或multiset中的键</h2><h2 id="考虑用排序的vector替代关联容器">考虑用排序的vector替代关联容器</h2><h2 id="当笑料至关重要时，请在map::operator[]与map::insert之间谨慎做出选择">当笑料至关重要时，请在map::operator[]与map::insert之间谨慎做出选择</h2><h2 id="熟悉非标准的散列容器">熟悉非标准的散列容器</h2><hr>
<h1 id="迭代器">迭代器</h1><h2 id="iterator优先于const_iterator,_reverse_iterator,_const_reverse_iterator">iterator优先于const_iterator, reverse_iterator, const_reverse_iterator</h2><h2 id="使用distance和advnace将容器的const_iteator转换成iterator">使用distance和advnace将容器的const_iteator转换成iterator</h2><h2 id="正确理解由reverse_iterator的base()成员函数所产生的iterator的用法">正确理解由reverse_iterator的base()成员函数所产生的iterator的用法</h2><h2 id="对于逐个字符的输入请考虑使用istreambuf_iterator">对于逐个字符的输入请考虑使用istreambuf_iterator</h2><hr>
<h1 id="算法">算法</h1><h2 id="确保目标区间足够大">确保目标区间足够大</h2><h2 id="了解各种和排序有关的选择">了解各种和排序有关的选择</h2><h2 id="如果确实需要删除元素，则需要在remove这一类算法之后调用erase">如果确实需要删除元素，则需要在remove这一类算法之后调用erase</h2><h2 id="对包含指针的容器使用remove这一类算法时要特别小心">对包含指针的容器使用remove这一类算法时要特别小心</h2><h2 id="了解哪些算法要求使用排序的区间作为参数">了解哪些算法要求使用排序的区间作为参数</h2><h2 id="通过mismatch或lexicographical_compare实现简单的忽略大小写的字符串比较">通过mismatch或lexicographical_compare实现简单的忽略大小写的字符串比较</h2><h2 id="理解copy_if算法的正确实现">理解copy_if算法的正确实现</h2><h2 id="使用accumulate或者for_each进行区间统计">使用accumulate或者for_each进行区间统计</h2><hr>
<h1 id="函数子，函数子类，函数及其他">函数子，函数子类，函数及其他</h1><h2 id="遵循按值传递的原则来设计函数子类">遵循按值传递的原则来设计函数子类</h2><h2 id="确保判别式是”纯函数”">确保判别式是”纯函数”</h2><h2 id="若一个类是函数子，则应使它可配接">若一个类是函数子，则应使它可配接</h2><h2 id="理解ptr_fun,_mem_fun和mem_fun_ref的来由">理解ptr_fun, mem_fun和mem_fun_ref的来由</h2><h2 id="确保less与operator&lt;具有相同的语义">确保less<t>与operator&lt;具有相同的语义</t></h2><hr>
<h1 id="在程序中使用STL">在程序中使用STL</h1><h2 id="算法调用优先于手写的循环">算法调用优先于手写的循环</h2><h2 id="容器的成员函数优先于同名的算法">容器的成员函数优先于同名的算法</h2><h2 id="正确区分const,_find,_binary_search,_lower_bound,_upper_bound和equal_range">正确区分const, find, binary_search, lower_bound, upper_bound和equal_range</h2><h2 id="考虑使用函数对象而不是函数作为STL算法的参数">考虑使用函数对象而不是函数作为STL算法的参数</h2><h2 id="考虑产生”直写型”的代码">考虑产生”直写型”的代码</h2><h2 id="总是包含正确的头文件">总是包含正确的头文件</h2><h2 id="学会分享与STL相关的编译器诊断信息">学会分享与STL相关的编译器诊断信息</h2><h2 id="熟悉与STL相关的Web站点">熟悉与STL相关的Web站点</h2>
  
</div>

    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/12/25/OpenGL-GLFW/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          OpenGL-GLFW
        
      </div>
    </a>
  
  
    <a href="/2015/12/20/Direct3D-Math/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Direct3D-Math</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="EffectiveSTL" data-title="Effective STL 总结" data-url="http://byhj.github.io/2015/12/24/EffectiveSTL/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 byhj
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>